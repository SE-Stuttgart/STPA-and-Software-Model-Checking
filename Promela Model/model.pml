// Generated by MODEX Version 2.7 - 1 January 2015
// So 22. Feb 19:31:14 CET 2015 from ACCSimulator.c
//Radar Sensor
 #define Received (1)
 #define NotReceived (0)
//ACC commands
#define accelerate (1)
#define deccelerate  (2)
#define resume (3)
//ACC Modes
#define off (1)
#define cruise  (2)
#define standby (3)
//radardata
#define Received (1)
#define NotReceived (0)
#define p1 c_expr{ Pp_controlSpeed->frontDistance <= now.safeDistance && now.accvehicle.currentspeed >= now.desiredSpeed && now.accMode==cruise}
 #define q1 c_expr{now.accOperation==accelerate}
#define p2 c_expr { (Pp_controlSpeed->frontDistance >= now.safeDistance && now.accvehicle.currentspeed >= now.desiredSpeed && now.accMode==cruise)}
#define q2 c_expr{(now.accOperation==deccelerate)}
 #define p3 c_expr { (Pp_controlSpeed->frontDistance <= now.safeDistance && now.accMode==cruise && now.accvehicle.currentspeed <= now.desiredSpeed)}
#define q3 c_expr{now.accOperation==accelerate}

#define p4  c_expr{( Pp_controlSpeed->frontDistance >= now.safeDistance && now.radarData==Received && now.accMode==cruise)}
#define q4 c_expr{(now.accOperation==deccelerate)}
 #define p5 c_expr{( Pp_controlSpeed->frontDistance > now.safeDistance && now.radarData==Received)}
#define q5 c_expr{(now.accOperation==accelerate)}
#define p6 c_expr { (now.accMode==cruise)}
#define q6 c_expr{(now.accvehicle.currentspeed <= now.desiredSpeed && now.accvehicle.currentspeed > 25.0)}
#define p7 c_expr { (now.accOperation==accelerate)} 
#define q7 c_expr { (now.accvehicle.currentspeed <= now.desiredSpeed)} 
#define p8 c_expr{ now.accMode==cruise}
#define q8 c_expr{(now.radarData==NotReceived)} 
 
  #include "neverpq0not.pml"
//#include "neverpq0.pml"
 
 c_state "long res_p_main" "Global"
bool lck_p_main_ret;
bool lck_p_main;
 c_state "void  * par0_runSimulator" "Global"
 c_state "long res_p_runSimulator" "Global"
bool lck_p_runSimulator_ret;
bool lck_p_runSimulator;
 c_state "void  * par0_radarSensorUnit" "Global"
 c_state "long res_p_radarSensorUnit" "Global"
bool lck_p_radarSensorUnit_ret;
bool lck_p_radarSensorUnit;
 c_state "void  * par0_moveCar" "Global"
 c_state "long res_p_moveCar" "Global"
bool lck_p_moveCar_ret;
bool lck_p_moveCar;
 c_state "double  par0_controlSpeed" "Global"
 c_state "double  par1_controlSpeed" "Global"
 c_state "double  par2_controlSpeed" "Global"
 c_state "long res_p_controlSpeed" "Global"
bool lck_p_controlSpeed_ret;
bool lck_p_controlSpeed;
 c_state "double  par0_adjustcarspeed" "Global"
 c_state "double  par1_adjustcarspeed" "Global"
 c_state "double  par2_adjustcarspeed" "Global"
 c_state "long res_p_adjustcarspeed" "Global"
bool lck_p_adjustcarspeed_ret;
bool lck_p_adjustcarspeed;
 c_state "double  par0_calPID" "Global"
 c_state "long res_p_calPID" "Global"
bool lck_p_calPID_ret;
bool lck_p_calPID;
 c_state "double  par0_transforfunction" "Global"
 c_state "long res_p_transforfunction" "Global"
bool lck_p_transforfunction_ret;
bool lck_p_transforfunction;
 c_state "long res_p_initTargetVehicle" "Global"
bool lck_p_initTargetVehicle_ret;
bool lck_p_initTargetVehicle;
 c_state "long res_p_initACCVehicle" "Global"
bool lck_p_initACCVehicle_ret;
bool lck_p_initACCVehicle;
 c_state "car targetvehicle" "Global"
 c_state "car accvehicle" "Global"
int enable = 1;
 c_state "double  safeDistance " "Global" "20"
 c_state "double  desiredSpeed " "Global" "65"
int radarData;
int accMode;
int accOperation;
int declerateSignal;
int acclerateSignal;
 c_state "double  maxSpeed " "Global" "240"
 c_state "double  minSpeed " "Global" "10"
 c_state "double  deccelerateRatio " "Global" "3"
 c_state "double  accelerationRatio " "Global" "2.5"
 c_state "double  timegap " "Global" "0.3"
chan ret_p_main = [1] of { pid };
chan exc_cll_p_main = [0] of { pid };
chan req_cll_p_main = [1] of { pid };
chan ret_p_runSimulator = [1] of { pid };
chan exc_cll_p_runSimulator = [0] of { pid };
chan req_cll_p_runSimulator = [1] of { pid };
chan ret_p_radarSensorUnit = [1] of { pid };
chan exc_cll_p_radarSensorUnit = [0] of { pid };
chan req_cll_p_radarSensorUnit = [1] of { pid };
chan ret_p_moveCar = [1] of { pid };
chan exc_cll_p_moveCar = [0] of { pid };
chan req_cll_p_moveCar = [1] of { pid };
chan ret_p_controlSpeed = [1] of { pid };
chan exc_cll_p_controlSpeed = [0] of { pid };
chan req_cll_p_controlSpeed = [1] of { pid };
chan ret_p_adjustcarspeed = [1] of { pid };
chan exc_cll_p_adjustcarspeed = [0] of { pid };
chan req_cll_p_adjustcarspeed = [1] of { pid };
chan ret_p_calPID = [1] of { pid };
chan exc_cll_p_calPID = [0] of { pid };
chan req_cll_p_calPID = [1] of { pid };
chan ret_p_transforfunction = [1] of { pid };
chan exc_cll_p_transforfunction = [0] of { pid };
chan req_cll_p_transforfunction = [1] of { pid };
chan ret_p_initTargetVehicle = [1] of { pid };
chan exc_cll_p_initTargetVehicle = [0] of { pid };
chan req_cll_p_initTargetVehicle = [1] of { pid };
chan ret_p_initACCVehicle = [1] of { pid };
chan exc_cll_p_initACCVehicle = [0] of { pid };
chan req_cll_p_initACCVehicle = [1] of { pid };
 c_state "void  * ptr" "Local p_runSimulator"
 c_state "void  * ptr" "Local p_radarSensorUnit"
 c_state "void  * ptr" "Local p_moveCar"
 c_state "double  speed" "Local p_controlSpeed"
 c_state "double  setSpeed" "Local p_controlSpeed"
 c_state "double  targetSpeed" "Local p_controlSpeed"
 c_state "double  deltaX" "Local p_controlSpeed"
 c_state "double  frontDistance" "Local p_controlSpeed"
 c_state "double  frontSpeed" "Local p_controlSpeed"
 c_state "double  currentSpeed" "Local p_controlSpeed"
 c_state "double  tspeed" "Local p_adjustcarspeed"
 c_state "double  distance" "Local p_adjustcarspeed"
 c_state "double  deltaX" "Local p_adjustcarspeed"
 c_state "double  vehicleSpeed" "Local p_adjustcarspeed"
 c_state "double  kd" "Local p_calPID"
 c_state "double  ki" "Local p_calPID"
 c_state "double  kp" "Local p_calPID"
 c_state "double  output" "Local p_calPID"
 c_state "double  error" "Local p_calPID"
 c_state "double  minvalue" "Local p_calPID"
 c_state "double  maxvalue" "Local p_calPID"
 c_state "double  deltatime" "Local p_calPID"
 c_state "double  preverror" "Local p_calPID"
 c_state "double  derivativegain" "Local p_calPID"
 c_state "double  integralgain" "Local p_calPID"
 c_state "double  proportionalgain" "Local p_calPID"
 c_state "double  epsilon" "Local p_calPID"
 c_state "double  diff" "Local p_calPID"
 c_state "double  s" "Local p_transforfunction"
c_decl { typedef struct car car; }
c_decl {
 struct car {
  double airResistance;
  volatile double maxBrake;
  volatile double speed;
  int ticksPerSecond;
  volatile int accmode;
  volatile double brakepedal;
  double wheelRadius[4];
  volatile double maxThrottle;
  volatile double brake;
  volatile double maxSpeed;
  int changesGear;
  int engineOn;
  int engineOff;
  volatile double currentspeed;
  double shift;
  volatile double throttle;
  int ignition;
  double gearRatio[8];
  char *name;
  signed int currentGear;
  volatile double distance;
  double shiftmargin;
  double enginerpmRedLine;
  int pressbrakepedal;
 };
}
active proctype p_initACCVehicle()
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_initACCVehicle) && !lck_p_initACCVehicle -> lck_p_initACCVehicle = 1;
 req_cll_p_initACCVehicle?lck_id; exc_cll_p_initACCVehicle?eval(lck_id);
 lck_p_initACCVehicle = 0;
 };
    c_code { now.accvehicle.accmode=3; };
    c_code { now.accvehicle.engineOff=0; };
    c_code { now.accvehicle.engineOn=1; };
    c_code { now.accvehicle.changesGear=0; };
    c_code { now.accvehicle.brakepedal=1; };
    c_code { now.accvehicle.currentspeed=0; };
    c_code { now.accvehicle.maxSpeed=240; };
    c_code { now.accvehicle.ignition=0; };
    c_code { now.accvehicle.gearRatio[0]=0; };
    c_code { now.accvehicle.gearRatio[1]=(3.9*4.5); };
    c_code { now.accvehicle.gearRatio[2]=(2.9*4.5); };
    c_code { now.accvehicle.gearRatio[3]=(2.3*4.5); };
    c_code { now.accvehicle.gearRatio[4]=(1.87*4.5); };
    c_code { now.accvehicle.gearRatio[5]=(1.68*4.5); };
    c_code { now.accvehicle.gearRatio[6]=(1.54*4.5); };
    c_code { now.accvehicle.gearRatio[7]=(1.46*4.5); };
    c_code { now.accvehicle.enginerpmRedLine=1958.26; };
    c_code { now.accvehicle.shift=0.95; };
    c_code { now.accvehicle.shiftmargin=0.95; };
    c_code { now.accvehicle.wheelRadius[0]=0.3024; };
    c_code { now.accvehicle.wheelRadius[1]=0.3024; };
    c_code { now.accvehicle.wheelRadius[2]=0.3151; };
    c_code { now.accvehicle.wheelRadius[3]=0.3151; };
    c_code { now.accvehicle.currentGear=0; };
    c_code { now.accvehicle.maxThrottle=10; };
    c_code { now.accvehicle.airResistance=(now.accvehicle.maxSpeed/now.accvehicle.maxThrottle); };
    c_code { now.accvehicle.ticksPerSecond=5; };
    c_code { now.accvehicle.distance=15; };
Return: skip;
 ret_p_initACCVehicle!lck_id;
 goto endRestart
}
active proctype p_initTargetVehicle()
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_initTargetVehicle) && !lck_p_initTargetVehicle -> lck_p_initTargetVehicle = 1;
 req_cll_p_initTargetVehicle?lck_id; exc_cll_p_initTargetVehicle?eval(lck_id);
 lck_p_initTargetVehicle = 0;
 };
    c_code { now.targetvehicle.accmode=1; };
    c_code { now.targetvehicle.engineOff=0; };
    c_code { now.targetvehicle.engineOn=1; };
    c_code { now.targetvehicle.changesGear=0; };
    c_code { now.targetvehicle.brakepedal=1; };
    c_code { now.targetvehicle.currentspeed=0; };
    c_code { now.targetvehicle.maxSpeed=240; };
    c_code { now.targetvehicle.ignition=0; };
    c_code { now.targetvehicle.gearRatio[0]=0; };
    c_code { now.targetvehicle.gearRatio[1]=(3.3*2.5); };
    c_code { now.targetvehicle.gearRatio[2]=(1.9*5.5); };
    c_code { now.targetvehicle.gearRatio[3]=(2.6*2.5); };
    c_code { now.targetvehicle.gearRatio[4]=(2*1.5); };
    c_code { now.targetvehicle.gearRatio[5]=(1*1.5); };
    c_code { now.targetvehicle.gearRatio[6]=(1*2.5); };
    c_code { now.targetvehicle.gearRatio[7]=(1*2.5); };
    c_code { now.targetvehicle.enginerpmRedLine=2318.26; };
    c_code { now.targetvehicle.shift=0.75; };
    c_code { now.targetvehicle.shiftmargin=0.95; };
    c_code { now.targetvehicle.wheelRadius[0]=0.1023; };
    c_code { now.targetvehicle.wheelRadius[1]=0.2023; };
    c_code { now.targetvehicle.wheelRadius[2]=0.2121; };
    c_code { now.targetvehicle.wheelRadius[3]=0.2121; };
    c_code { now.targetvehicle.currentGear=0; };
    c_code { now.targetvehicle.maxThrottle=10; };
    c_code { now.targetvehicle.airResistance=(now.accvehicle.maxSpeed/now.accvehicle.maxThrottle); };
    c_code { now.targetvehicle.ticksPerSecond=5; };
    c_code { now.targetvehicle.distance=15; };
Return: skip;
 ret_p_initTargetVehicle!lck_id;
 goto endRestart
}
active proctype p_transforfunction( )
{
int b = 50;
int u = 500;
int m = 1000;
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_transforfunction) && !lck_p_transforfunction -> lck_p_transforfunction = 1;
 req_cll_p_transforfunction?lck_id; exc_cll_p_transforfunction?eval(lck_id);
 c_code { Pp_transforfunction->s = now.par0_transforfunction; };
 lck_p_transforfunction = 0;
 };
     atomic { !lck_p_transforfunction_ret -> lck_p_transforfunction_ret = 1 };
 c_code { now.res_p_transforfunction = (long) (1/((1000*Pp_transforfunction->s)+50)); }; goto Return;
Return: skip;
 ret_p_transforfunction!lck_id;
 goto endRestart
}
active proctype p_calPID( )
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_calPID) && !lck_p_calPID -> lck_p_calPID = 1;
 req_cll_p_calPID?lck_id; exc_cll_p_calPID?eval(lck_id);
 c_code { Pp_calPID->diff = now.par0_calPID; };
 lck_p_calPID = 0;
 };
    c_code { Pp_calPID->epsilon=0.01; };
    c_code { Pp_calPID->deltatime=0.01; };
    c_code { Pp_calPID->maxvalue=200; };
    c_code { Pp_calPID->minvalue=0; };
    c_code { Pp_calPID->kp=2000; };
    c_code { Pp_calPID->ki=80; };
    c_code { Pp_calPID->kd=80; };
    c_code { Pp_calPID->preverror=0; };
    c_code { Pp_calPID->integralgain=0; };
    c_code { Pp_calPID->error=Pp_calPID->diff; };
    if
    :: c_expr { (Pp_calPID->error>Pp_calPID->epsilon) };
        c_code { Pp_calPID->integralgain+=(Pp_calPID->error*Pp_calPID->deltatime); };
    :: c_expr { !(Pp_calPID->error>Pp_calPID->epsilon) };
 fi;
    c_code { Pp_calPID->derivativegain+=((Pp_calPID->error-Pp_calPID->preverror)/Pp_calPID->deltatime); };
    c_code { Pp_calPID->output=(((Pp_calPID->kp*Pp_calPID->error)+(Pp_calPID->ki*Pp_calPID->integralgain))+(Pp_calPID->kd*Pp_calPID->derivativegain)); };
    if
    :: c_expr { (Pp_calPID->output>Pp_calPID->maxvalue) };
        c_code { Pp_calPID->output=Pp_calPID->maxvalue; };
    :: c_expr { !(Pp_calPID->output>Pp_calPID->maxvalue) };
      if
      :: c_expr { (Pp_calPID->output<Pp_calPID->minvalue) };
          c_code { Pp_calPID->output=Pp_calPID->minvalue; };
      :: c_expr { !(Pp_calPID->output<Pp_calPID->minvalue) };
 fi;
 fi;
 atomic {
  lck_p_transforfunction == 0 && empty(req_cll_p_transforfunction) -> req_cll_p_transforfunction!_pid;
  c_code { now.par0_transforfunction = Pp_calPID->output; };
  exc_cll_p_transforfunction!_pid;
 }
 ret_p_transforfunction?eval(_pid);
 c_code { Pp_calPID->output= now.res_p_transforfunction; now.lck_p_transforfunction_ret = 0; };
    c_code { Pp_calPID->preverror=Pp_calPID->error; };
     atomic { !lck_p_calPID_ret -> lck_p_calPID_ret = 1 };
 c_code { now.res_p_calPID = (long) Pp_calPID->output; }; goto Return;
Return: skip;
 ret_p_calPID!lck_id;
 goto endRestart
}
active proctype p_adjustcarspeed( )
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_adjustcarspeed) && !lck_p_adjustcarspeed -> lck_p_adjustcarspeed = 1;
 req_cll_p_adjustcarspeed?lck_id; exc_cll_p_adjustcarspeed?eval(lck_id);
 c_code { Pp_adjustcarspeed->distance = now.par2_adjustcarspeed; };
 c_code { Pp_adjustcarspeed->deltaX = now.par1_adjustcarspeed; };
 c_code { Pp_adjustcarspeed->vehicleSpeed = now.par0_adjustcarspeed; };
 lck_p_adjustcarspeed = 0;
 };
    c_code { Pp_adjustcarspeed->tspeed=0; };
    if
    :: c_expr { (now.accOperation==1) };
        c_code { Pp_adjustcarspeed->tspeed=sqrt(((Pp_adjustcarspeed->vehicleSpeed*Pp_adjustcarspeed->vehicleSpeed)+abs(((2*(-now.accelerationRatio))*abs(((Pp_adjustcarspeed->deltaX+now.safeDistance)-Pp_adjustcarspeed->distance)))))); };
    :: c_expr { !(now.accOperation==1) };
      if
      :: c_expr { (now.accOperation==2) };
          c_code { Pp_adjustcarspeed->tspeed=sqrt(((Pp_adjustcarspeed->vehicleSpeed*Pp_adjustcarspeed->vehicleSpeed)+abs(((2*(-now.accelerationRatio))*abs((now.safeDistance-Pp_adjustcarspeed->distance)))))); };
      :: c_expr { !(now.accOperation==2) };
        if
        :: c_expr { (now.accOperation==3) };
            c_code { Pp_adjustcarspeed->tspeed=(Pp_adjustcarspeed->vehicleSpeed+(now.accelerationRatio*now.timegap)); };
        :: c_expr { !(now.accOperation==3) };
 fi;
 fi;
 fi;
     atomic { !lck_p_adjustcarspeed_ret -> lck_p_adjustcarspeed_ret = 1 };
 c_code { now.res_p_adjustcarspeed = (long) Pp_adjustcarspeed->tspeed; }; goto Return;
Return: skip;
 ret_p_adjustcarspeed!lck_id;
 goto endRestart
}
active proctype p_controlSpeed( )
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_controlSpeed) && !lck_p_controlSpeed -> lck_p_controlSpeed = 1;
 req_cll_p_controlSpeed?lck_id; exc_cll_p_controlSpeed?eval(lck_id);
 c_code { Pp_controlSpeed->frontDistance = now.par2_controlSpeed; };
 c_code { Pp_controlSpeed->frontSpeed = now.par1_controlSpeed; };
 c_code { Pp_controlSpeed->currentSpeed = now.par0_controlSpeed; };
 lck_p_controlSpeed = 0;
 };
    c_code { Pp_controlSpeed->deltaX=0; };
    c_code { Pp_controlSpeed->targetSpeed=0; };
    c_code { Pp_controlSpeed->setSpeed=0; };
    c_code { Pp_controlSpeed->speed=0; };
    if
    :: c_expr { (Pp_controlSpeed->currentSpeed==0) };
        c_code { Pp_controlSpeed->currentSpeed=now.minSpeed; };
    :: c_expr { !(Pp_controlSpeed->currentSpeed==0) };
 fi;
    c_code { Pp_controlSpeed->deltaX=abs((((Pp_controlSpeed->frontSpeed*Pp_controlSpeed->frontSpeed)-(Pp_controlSpeed->currentSpeed*Pp_controlSpeed->currentSpeed))/(2*(-now.accelerationRatio)))); };
    if
    :: c_expr { (Pp_controlSpeed->frontDistance<=(now.safeDistance+Pp_controlSpeed->deltaX)) };
        if
        :: c_expr { ((Pp_controlSpeed->frontDistance<=(Pp_controlSpeed->deltaX+now.safeDistance))&&(Pp_controlSpeed->frontDistance>=now.safeDistance)) };
            c_code { now.accOperation=1; };
 atomic {
  lck_p_adjustcarspeed == 0 && empty(req_cll_p_adjustcarspeed) -> req_cll_p_adjustcarspeed!_pid;
  c_code { now.par0_adjustcarspeed = Pp_controlSpeed->currentSpeed; };
  c_code { now.par1_adjustcarspeed = Pp_controlSpeed->deltaX; };
  c_code { now.par2_adjustcarspeed = Pp_controlSpeed->frontDistance; };
  exc_cll_p_adjustcarspeed!_pid;
 }
 ret_p_adjustcarspeed?eval(_pid);
 c_code { Pp_controlSpeed->speed= now.res_p_adjustcarspeed; now.lck_p_adjustcarspeed_ret = 0; };
            if
            :: c_expr { (Pp_controlSpeed->frontSpeed>=Pp_controlSpeed->speed) };
                c_code { Pp_controlSpeed->setSpeed=Pp_controlSpeed->frontSpeed; };
            :: c_expr { !(Pp_controlSpeed->frontSpeed>=Pp_controlSpeed->speed) };
              c_code { Pp_controlSpeed->setSpeed=Pp_controlSpeed->speed; };
 fi;
            c_code { now.acclerateSignal=1; };
            c_code { now.accvehicle.accmode=2; };
        :: c_expr { !((Pp_controlSpeed->frontDistance<=(Pp_controlSpeed->deltaX+now.safeDistance))&&(Pp_controlSpeed->frontDistance>=now.safeDistance)) };
          if
          :: c_expr { (Pp_controlSpeed->frontDistance<now.safeDistance) };
              c_code { now.accOperation=2; };
 atomic {
  lck_p_adjustcarspeed == 0 && empty(req_cll_p_adjustcarspeed) -> req_cll_p_adjustcarspeed!_pid;
  c_code { now.par0_adjustcarspeed = Pp_controlSpeed->currentSpeed; };
  c_code { now.par1_adjustcarspeed = Pp_controlSpeed->deltaX; };
  c_code { now.par2_adjustcarspeed = Pp_controlSpeed->frontDistance; };
  exc_cll_p_adjustcarspeed!_pid;
 }
 ret_p_adjustcarspeed?eval(_pid);
 c_code { Pp_controlSpeed->speed= now.res_p_adjustcarspeed; now.lck_p_adjustcarspeed_ret = 0; };
              if
              :: c_expr { (now.minSpeed>=Pp_controlSpeed->speed) };
                  c_code { Pp_controlSpeed->setSpeed=now.minSpeed; };
              :: c_expr { !(now.minSpeed>=Pp_controlSpeed->speed) };
                c_code { Pp_controlSpeed->setSpeed=Pp_controlSpeed->speed; };
 fi;
              c_code { now.accvehicle.accmode=2; };
          :: c_expr { !(Pp_controlSpeed->frontDistance<now.safeDistance) };
 fi;
 fi;
    :: c_expr { !(Pp_controlSpeed->frontDistance<=(now.safeDistance+Pp_controlSpeed->deltaX)) };
      if
      :: c_expr { ((Pp_controlSpeed->frontDistance>(now.safeDistance+Pp_controlSpeed->deltaX))&&(Pp_controlSpeed->frontDistance>=now.safeDistance)) };
          c_code { now.accOperation=3; };
          c_code { Pp_controlSpeed->setSpeed=(Pp_controlSpeed->currentSpeed+(now.accelerationRatio*now.timegap)); };
          c_code { now.accvehicle.accmode=2; };
      :: c_expr { !((Pp_controlSpeed->frontDistance>(now.safeDistance+Pp_controlSpeed->deltaX))&&(Pp_controlSpeed->frontDistance>=now.safeDistance)) };
 fi;
 fi;
    if
    :: c_expr { (now.desiredSpeed<=Pp_controlSpeed->speed) };
        c_code { Pp_controlSpeed->setSpeed=now.desiredSpeed; };
    :: c_expr { !(now.desiredSpeed<=Pp_controlSpeed->speed) };
      c_code { Pp_controlSpeed->setSpeed=Pp_controlSpeed->setSpeed; };
 fi;
 atomic {
  lck_p_calPID == 0 && empty(req_cll_p_calPID) -> req_cll_p_calPID!_pid;
  c_code { now.par0_calPID = (Pp_controlSpeed->setSpeed-Pp_controlSpeed->currentSpeed); };
  exc_cll_p_calPID!_pid;
 }
 ret_p_calPID?eval(_pid);
 c_code { Pp_controlSpeed->targetSpeed= now.res_p_calPID; now.lck_p_calPID_ret = 0; };
     atomic { !lck_p_controlSpeed_ret -> lck_p_controlSpeed_ret = 1 };
 c_code { now.res_p_controlSpeed = (long) Pp_controlSpeed->targetSpeed; }; goto Return;
Return: skip;
 ret_p_controlSpeed!lck_id;
 goto endRestart
}
active proctype p_moveCar( )
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_moveCar) && !lck_p_moveCar -> lck_p_moveCar = 1;
 req_cll_p_moveCar?lck_id; exc_cll_p_moveCar?eval(lck_id);
 c_code { Pp_moveCar->ptr = now.par0_moveCar; };
 lck_p_moveCar = 0;
 };
    if
    :: c_expr { (now.accvehicle.brakepedal>0) };
        c_code { now.accvehicle.brakepedal=0; };
    :: c_expr { !(now.accvehicle.brakepedal>0) };
      if
      :: c_expr { (now.accvehicle.throttle<(now.accvehicle.maxThrottle-1)) };
          c_code { now.accvehicle.throttle+=1; };
      :: c_expr { !(now.accvehicle.throttle<(now.accvehicle.maxThrottle-1)) };
        c_code { now.accvehicle.throttle=now.accvehicle.maxThrottle; };
 fi;
 fi;
    c_code { now.accMode=now.accvehicle.accmode; };
    if
    :: c_expr { (now.accMode==2) };
        c_code { now.radarData=1; };
 atomic {
  lck_p_controlSpeed == 0 && empty(req_cll_p_controlSpeed) -> req_cll_p_controlSpeed!_pid;
  c_code { now.par0_controlSpeed = now.accvehicle.currentspeed; };
  c_code { now.par1_controlSpeed = now.targetvehicle.speed; };
  c_code { now.par2_controlSpeed = now.targetvehicle.distance; };
  exc_cll_p_controlSpeed!_pid;
 }
 ret_p_controlSpeed?eval(_pid);
 c_code { now.accvehicle.speed+= now.res_p_controlSpeed; now.lck_p_controlSpeed_ret = 0; };
        if
        :: c_expr { (now.accvehicle.speed>now.accvehicle.maxSpeed) };
            c_code { now.accvehicle.speed=now.accvehicle.maxSpeed; };
        :: c_expr { !(now.accvehicle.speed>now.accvehicle.maxSpeed) };
          if
          :: c_expr { (now.accvehicle.speed<now.minSpeed) };
              c_code { now.accvehicle.speed=now.minSpeed; };
          :: c_expr { !(now.accvehicle.speed<now.minSpeed) };
 fi;
 fi;
        c_code { now.accvehicle.currentspeed=now.accvehicle.speed; };
        do
        :: c_expr { 1 == now.accOperation };
            c_code { now.accvehicle.speed=(now.accvehicle.speed+now.accelerationRatio); };
        c_code { now.accvehicle.currentspeed=now.accvehicle.speed; };
 atomic {
  lck_p_controlSpeed == 0 && empty(req_cll_p_controlSpeed) -> req_cll_p_controlSpeed!_pid;
  c_code { now.par0_controlSpeed = now.accvehicle.currentspeed; };
  c_code { now.par1_controlSpeed = now.targetvehicle.speed; };
  c_code { now.par2_controlSpeed = now.targetvehicle.distance; };
  exc_cll_p_controlSpeed!_pid;
 }
 ret_p_controlSpeed?eval(_pid);
 c_code { now.accvehicle.speed+= now.res_p_controlSpeed; now.lck_p_controlSpeed_ret = 0; };
                break;
          goto C_0
        :: c_expr { 2 == now.accOperation };
C_0: c_code { now.accvehicle.speed=(now.accvehicle.speed-now.deccelerateRatio); };
        c_code { now.accvehicle.currentspeed=now.accvehicle.speed; };
 atomic {
  lck_p_controlSpeed == 0 && empty(req_cll_p_controlSpeed) -> req_cll_p_controlSpeed!_pid;
  c_code { now.par0_controlSpeed = now.accvehicle.currentspeed; };
  c_code { now.par1_controlSpeed = now.targetvehicle.speed; };
  c_code { now.par2_controlSpeed = now.targetvehicle.distance; };
  exc_cll_p_controlSpeed!_pid;
 }
 ret_p_controlSpeed?eval(_pid);
 c_code { now.accvehicle.speed-= now.res_p_controlSpeed; now.lck_p_controlSpeed_ret = 0; };
                break;
          goto C_1
        :: c_expr { 3 == now.accOperation };
C_1:
        c_code { now.accvehicle.currentspeed=now.desiredSpeed; };
 atomic {
  lck_p_controlSpeed == 0 && empty(req_cll_p_controlSpeed) -> req_cll_p_controlSpeed!_pid;
  c_code { now.par0_controlSpeed = now.accvehicle.currentspeed; };
  c_code { now.par1_controlSpeed = now.targetvehicle.speed; };
  c_code { now.par2_controlSpeed = now.targetvehicle.distance; };
  exc_cll_p_controlSpeed!_pid;
 }
 ret_p_controlSpeed?eval(_pid);
 c_code { now.accvehicle.speed+= now.res_p_controlSpeed; now.lck_p_controlSpeed_ret = 0; };
                break;
          goto C_2
        :: else -> break
        od;
C_2: skip; if
        :: c_expr { (now.accvehicle.speed>now.desiredSpeed) };
            c_code { now.accvehicle.speed=now.desiredSpeed; };
        :: c_expr { !(now.accvehicle.speed>now.desiredSpeed) };
          if
          :: c_expr { (now.accvehicle.speed<0) };
              c_code { now.accvehicle.speed=now.minSpeed; };
          :: c_expr { !(now.accvehicle.speed<0) };
 fi;
 fi;
    :: c_expr { !(now.accMode==2) };
      c_code { now.accvehicle.speed=((now.accvehicle.speed+(((now.accvehicle.throttle-(now.accvehicle.speed/now.accvehicle.airResistance))-(2*now.accvehicle.brakepedal))/now.accvehicle.ticksPerSecond))*2); };
      if
      :: c_expr { (now.accvehicle.speed>now.desiredSpeed) };
          c_code { now.accvehicle.speed=now.desiredSpeed; };
      :: c_expr { !(now.accvehicle.speed>now.desiredSpeed) };
        if
        :: c_expr { (now.accvehicle.speed<0) };
            c_code { now.accvehicle.speed=now.minSpeed; };
        :: c_expr { !(now.accvehicle.speed<0) };
 fi;
 fi;
      c_code { now.accvehicle.currentspeed=now.accvehicle.speed; };
      if
      :: c_expr { (now.accvehicle.throttle>0) };
          c_code { now.accvehicle.throttle-=(0.5/now.accvehicle.ticksPerSecond); };
      :: c_expr { !(now.accvehicle.throttle>0) };
 fi;
 fi;
    if
    :: c_expr { (now.accvehicle.currentspeed<25) };
        c_code { now.accvehicle.accmode=1; };
        c_code { now.accMode=1; };
    :: c_expr { !(now.accvehicle.currentspeed<25) };
 fi;
Return: skip;
 ret_p_moveCar!lck_id;
 goto endRestart
}
active proctype p_radarSensorUnit( )
{
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_radarSensorUnit) && !lck_p_radarSensorUnit -> lck_p_radarSensorUnit = 1;
 req_cll_p_radarSensorUnit?lck_id; exc_cll_p_radarSensorUnit?eval(lck_id);
 c_code { Pp_radarSensorUnit->ptr = now.par0_radarSensorUnit; };
 lck_p_radarSensorUnit = 0;
 };
    c_code { now.targetvehicle.speed=((rand()%((240-20)+1))+20); };
    c_code { now.targetvehicle.distance=(now.targetvehicle.distance+((now.accvehicle.speed/36)/now.targetvehicle.ticksPerSecond)); };
Return: skip;
 ret_p_radarSensorUnit!lck_id;
 goto endRestart
}
active proctype p_runSimulator( )
{
int step = 0;
int t_moveCar;
int t_radarSensor;
pid lck_id;
endRestart:
 atomic {
 nempty(req_cll_p_runSimulator) && !lck_p_runSimulator -> lck_p_runSimulator = 1;
 req_cll_p_runSimulator?lck_id; exc_cll_p_runSimulator?eval(lck_id);
 c_code { Pp_runSimulator->ptr = now.par0_runSimulator; };
 lck_p_runSimulator = 0;
 };
    c_code { now.minSpeed=10; };
    c_code { now.desiredSpeed=65; };
    c_code { now.safeDistance=20; };
 atomic {
  lck_p_initACCVehicle == 0 && empty(req_cll_p_initACCVehicle) -> req_cll_p_initACCVehicle!_pid;
  exc_cll_p_initACCVehicle!_pid;
 }
 ret_p_initACCVehicle?eval(_pid);
 c_code { ; now.lck_p_initACCVehicle_ret = 0; };
 atomic {
  lck_p_initTargetVehicle == 0 && empty(req_cll_p_initTargetVehicle) -> req_cll_p_initTargetVehicle!_pid;
  exc_cll_p_initTargetVehicle!_pid;
 }
 ret_p_initTargetVehicle?eval(_pid);
 c_code { ; now.lck_p_initTargetVehicle_ret = 0; };
    c_code { now.accvehicle.name="accVehilce"; };
    c_code { now.targetvehicle.name="targetvehicle"; };
    c_code { now.accvehicle.speed=now.minSpeed; };
    c_code { now.accvehicle.currentspeed=now.minSpeed; };
    c_code { now.radarData=0; };
L_0:
    do
    :: true;
         atomic {
  lck_p_radarSensorUnit == 0 && empty(req_cll_p_radarSensorUnit) -> req_cll_p_radarSensorUnit!_pid;
  c_code { now.par0_radarSensorUnit = NULL; };
  exc_cll_p_radarSensorUnit!_pid;
 }
         atomic {
  lck_p_moveCar == 0 && empty(req_cll_p_moveCar) -> req_cll_p_moveCar!_pid;
  c_code { now.par0_moveCar = NULL; };
  exc_cll_p_moveCar!_pid;
 }
        if
        :: c_expr { (now.accvehicle.currentspeed<now.desiredSpeed) };
            c_code { now.accvehicle.accmode=3; };
            c_code { now.accMode=3; };
        :: c_expr { !(now.accvehicle.currentspeed<now.desiredSpeed) };
          if
          :: c_expr { (now.accvehicle.currentspeed==now.desiredSpeed) };
              c_code { now.radarData=1; };
              c_code { now.accvehicle.accmode=2; };
              c_code { now.accMode=2; };
          :: c_expr { !(now.accvehicle.currentspeed==now.desiredSpeed) };
            if
            :: c_expr { (now.accvehicle.currentspeed>now.desiredSpeed) };
                c_code { now.accvehicle.currentspeed=now.desiredSpeed; };
            :: c_expr { !(now.accvehicle.currentspeed>now.desiredSpeed) };
 fi;
 fi;
 fi;
c_code { Pp_runSimulator->step++; };
         ret_p_radarSensorUnit?eval(_pid);
 c_code { now.lck_p_radarSensorUnit_ret = 0; };
         ret_p_moveCar?eval(_pid);
 c_code { now.lck_p_moveCar_ret = 0; };
    goto L_0;
    :: c_expr { !1 }; -> break
    od;
     atomic { !lck_p_runSimulator_ret -> lck_p_runSimulator_ret = 1 };
 c_code { now.res_p_runSimulator = (long) NULL; }; goto Return;
Return: skip;
 ret_p_runSimulator!lck_id;
 goto endRestart
}
active proctype p_main( )
{
int t_simulator;
pid lck_id;
     atomic {
  lck_p_runSimulator == 0 && empty(req_cll_p_runSimulator) -> req_cll_p_runSimulator!_pid;
  c_code { now.par0_runSimulator = NULL; };
  exc_cll_p_runSimulator!_pid;
 }
     goto Return;
    c_code { getchar(); };
     atomic { !lck_p_main_ret -> lck_p_main_ret = 1 };
 c_code { now.res_p_main = (long) 0; }; goto Return;
Return: skip;
}

